# stepik_final_task
The finishing line
-------------------
# Подготовка окружения

1. Создайте отдельный публичный репозиторий с осмысленным названием на GitHub.

2. Склонируйте его к себе на локальную машину.

3. Добавьте туда файл conftest.py из предыдущего модуля. Убедитесь дополнительно, что там есть параметр для задания языка интерфейса, по умолчанию равный "en".

4. Убедитесь что ни во вложенных папках, ни во внешних папках нет других файлов conftest.py, почему это важно смотри здесь: Conftest.py — конфигурация тестов.

5. Добавьте в репозиторий файл requirements.txt из предыдущего модуля. 

6. Создайте пустой файл __init__.py, чтобы работали относительные импорты.

7. Создайте файл test_main_page.py и добавьте в него тест из предыдущего модуля: 
```
def test_guest_can_go_to_login_page(browser):
    link = "http://selenium1py.pythonanywhere.com/"
    browser.get(link)
    login_link = browser.find_element(By.CSS_SELECTOR, "#login_link")
    login_link.click()
```
8. Не забудьте активировать окружение, которое мы создали ранее. Опционально, можно создать для этого проекта новое виртуальное окружение для удобства. В таком случае убедитесь что вы установили туда все необходимые пакеты из requirements.txt. А еще не стоит добавлять файлы окружения в репозиторий и вообще в отслеживаемые — лишние файлы на GitHub это моветон. 

9. Убедитесь, что тест работает, с помощью следующей команды: pytest -v --tb=line --language=en test_main_page.py. Здесь и далее мы будем использовать эту команду для запуска. В этой команде мы использовали опцию PyTest --tb=line, которая указывает, что нужно выводить только одну строку из лога каждого упавшего теста. Так вам будет проще разобраться в том, как выглядят сообщения об ошибках.

10. Добавьте все новые файлы в Git командой git add *

11. Проверьте, что нужные файлы попали в планируемый коммит: git status

12. Зафиксируйте изменения коммитом с осмысленным сообщением: git commit -m "write your message".

13. По желанию добавьте описание репозитория с описанием вашего тестового проекта.

--------------------------------------------

# Базовая страница для проекта: BasePage

1. Создайте в своем проекте папку pages, там мы будем хранить все наши Page Object 

2. В папке создайте два файла: base_page.py и main_page.py  

Для начала сделаем базовую страницу, от которой будут унаследованы все остальные классы. В ней мы опишем вспомогательные методы для работы с драйвером.

3. В файле base_page.py создайте класс с названием BasePage. 

В Python такие вещи делаются с помощью следующей конструкции: 
```
class BasePage():
```
                  
4. Теперь в наш класс нужно добавить методы. Первым делом добавим конструктор — метод, который вызывается, когда мы создаем объект. Конструктор объявляется ключевым словом __init__. В него в качестве параметров мы передаем экземпляр драйвера и url адрес. Внутри конструктора сохраняем эти данные как аттрибуты нашего класса. Получается примерно так: 
```
def __init__(self, browser, url):
    self.browser = browser
    self.url = url
```
                  
5. Теперь добавим еще один метод open. Он должен открывать нужную страницу в браузере, используя метод get().

Объявите ниже в том же классе:
```
def open(self):
```
и реализуйте этот метод: нужна всего одна строка. Эту строку нужно отправить в качестве ответа на это задание, без отступов. 

6. После того как Stepik принял ваш ответ как правильный, добавьте новые файлы в Git и зафиксируйте изменения коммитом (не забудьте осмысленное сообщение).

В итоге у вас должен следующий код в файле base_page.py: 
```
class BasePage():
    def __init__(self, browser, url):
        self.browser = browser
        self.url = url

    def open(self): 
        # ваша реализация
```

------------------------------------------

# Page Object для главной страницы сайта

1. Откройте файл main_page.py 

2. В нем нужно сделать импорт базового класса BasePage: 
```
from .base_page import BasePage
```
                  
3. В нем создайте класс  MainPage. Его нужно сделать наследником класса BasePage. Класс-предок в Python указывается в скобках: 
```
class MainPage(BasePage): 
```
таким образом, класс MainPage будет иметь доступ ко всем атрибутам и методам своего класса-предка. 

4. Перенесите метод из предыдущего урока в класс MainPage:
```
def go_to_login_page(browser):
   login_link = browser.find_element(By.CSS_SELECTOR, "#login_link")
   login_link.click() 
```
                  
Чтобы все работало, надо слегка видоизменить его. В аргументы больше не надо передавать экземпляр браузера, мы его передаем и сохраняем на этапе создания Page Object. Вместо него нужно указать аргумент self , чтобы иметь доступ к атрибутам и методам класса: 
```
def go_to_login_page(self):
```
Так как браузер у нас хранится как аргумент класса BasePage, обращаться к нему нужно соответствующим образом с помощью self: 
```
self.browser.find_element(By.CSS_SELECTOR, "#login_link")
```
                  
Итого, файл main_page.py будет выглядеть так: 
```
from .base_page import BasePage
from selenium.webdriver.common.by import By

class MainPage(BasePage): 
    def go_to_login_page(self):
        login_link = self.browser.find_element(By.CSS_SELECTOR, "#login_link")
        login_link.click()
```

--------------------------------------

# Первый тест на основе Page Object

1. Откройте файл с вашим тестом test_main_page.py

2. В самом верху файла нужно импортировать класс, описывающий главную страницу: 
```
from .pages.main_page import MainPage
```
3. Теперь преобразуем сам тест в test_main_page.py: 
```
from .pages.main_page import MainPage

def test_guest_can_go_to_login_page(browser):
    link = "http://selenium1py.pythonanywhere.com/"
    page = MainPage(browser, link)   # инициализируем Page Object, передаем в конструктор экземпляр драйвера и url адрес 
    page.open()                      # открываем страницу
    page.go_to_login_page()          # выполняем метод страницы — переходим на страницу логина

```            
4. Убедитесь, что тест проходит, запустив его все той же командой: 
```
pytest -v --tb=line --language=en test_main_page.py
```
5. Добавьте изменения и сделайте коммит (с осмысленным сообщением!)

----------------------------------------

# Методы-проверки в Page Object

Допустим, нам нужно проверять такой сценарий: 

2. Открыть главную страницу 
3. роверить, что есть ссылка, которая ведет на логин 

Для этого в классе MainPage нужно реализовать метод, который будет проверять наличие ссылки. Обычно все такие методы-проверки называются похожим образом, мы будем называть их should_be_(название элемента). 

Итак, в классе MainPage создайте метод should_be_login_link. 

Для первой пробы можно реализовать его самым примитивным образом: 

```
def should_be_login_link(self):
    self.browser.find_element(By.CSS_SELECTOR, "#login_link_invalid")
```
                  
Сейчас мы намеренно сделали селектор неправильным, чтобы посмотреть, что именно выдаст тест, если поймает баг. Это хорошая практика: писать сначала красные тесты и только потом делать их зелеными.  

Добавляем в файл с тест-кейсами новый тест: 

```
def test_guest_should_see_login_link(browser):
    link = "http://selenium1py.pythonanywhere.com/"
    page = MainPage(browser, link)
    page.open()
    page.should_be_login_link()
```
                  
Запустите получившийся тест: 
```
pytest -v --tb=line --language=en test_main_page.py
```
------------------------------------
# Проверка элемента на странице

Чтобы выводить адекватное сообщение об ошибке, мы будем все проверки осуществлять с помощью assert и перехватывать исключения.

Для этого напишем вспомогательный метод поиска элемента в нашей базовой странице BasePage, который будет возвращать нам True или False. Можно сделать это по-разному (с настройкой явных или неявных ожиданий). Сейчас воспользуемся неявным ожиданием.

1. В конструктор BasePage добавим команду для неявного ожидания со значением по умолчанию в 10:
```
def __init__(self, browser, url, timeout=10):
    self.browser = browser
    self.url = url
    self.browser.implicitly_wait(timeout)
```
                  
2. Теперь в этом же классе реализуем метод is_element_present, в котором будем перехватывать исключение. В него будем передавать два аргумента: как искать (css, id, xpath и тд) и собственно что искать (строку-селектор). 

Чтобы перехватывать исключение, нужна конструкция try/except: 
```
def is_element_present(self, how, what):
    try:
        self.browser.find_element(how, what)
    except (имя исключения):
        return False
    return True
```
                  
Чтобы импортировать нужное нам исключение, в самом верху файла нужно указать: 
```
from selenium.common.exceptions import имя_исключения
```

Отлично! Теперь для всех проверок, что элемент действительно присутствует на странице, мы можем использовать этот метод. 

3. Теперь модифицируем метод проверки ссылки на логин так, чтобы он выдавал адекватное сообщение об ошибке: 
```
def should_be_login_link(self):
    assert self.is_element_present(By.CSS_SELECTOR, "#login_link_invalid"), "Login link is not presented"
```
                  
Запустите тесты и посмотрите, что вывод об ошибке стал более понятным: 
```
pytest -v --tb=line --language=en test_main_page.py
```
                  
И не забудьте заменить селектор на правильный, чтобы тест снова проходил! 

4. Сделайте коммит изменений (с осмысленным сообщением).

------------------------
# Элементы страниц в паттерне Page Object

1. В папке pages создайте новый файл locators.py 

2. Внутри создайте новый класс. Каждый класс будет соответствовать каждому классу PageObject:
```
from selenium.webdriver.common.by import By

class MainPageLocators():
    LOGIN_LINK = (By.CSS_SELECTOR, "#login_link")
```
                  
теперь каждый селектор — это пара: как искать и что искать. 

3. В файле main_page.py импортируйте новый класс с локаторами 
```
from .locators import MainPageLocators
```
                  
4. Теперь в классе MainPage замените все строки, где содержится "#login_link" таким образом:
```
def should_be_login_link(self):
    assert self.is_element_present(*MainPageLocators.LOGIN_LINK), "Login link is not presented"
```
                  
Обратите внимание здесь на символ *, он указывает на то, что мы передали именно пару, и этот кортеж нужно распаковать. 

5. Запустите тесты с помощью той же самой команды: 
```
pytest -v --tb=line --language=en test_main_page.py
```
                  
Они, конечно, снова упадут. Но теперь посчитайте, сколько строк вам нужно будет отредактировать, когда тесты написаны в такой конфигурации? Внесите число во второе поле ответа. 

Итак, PageObject — это не только методы, но и элементы.  

Исправлять руками сломанные селекторы во всем проекте — долго и муторно, и есть большой риск забыть и оставить старый селектор. Когда мы выносим селекторы в отдельную сущность, мы уменьшаем время на поддержку тестов и сильно упрощаем себе жизнь в долгосрочной перспективе. 

А ещё спринт спустя промоакция закончилась, и фичу с изменением шапки откатили назад. Теперь ссылка работает так же, как раньше. Удалите ссылку с промоакцией, и верните обычную ссылку для запуска тестов: 
```
link = "http://selenium1py.pythonanywhere.com/"
```
                  
Не забудьте вернуть старый селектор #login_link, так чтобы тесты снова проходили. Они нам еще пригодятся! 

-------------------------------
# Реализация LoginPage

1. В файле locators.py создайте класс LoginPageLocators 

2. Подберите селекторы к формам регистрации и логина, добавьте их в класс LoginPageLocators

3. Напишите проверки, используя эти селекторы. Не забудьте через запятую указать адекватное сообщение об ошибке. Напишите сначала красный тест, чтобы убедиться в понятности вывода. 

4. В методе should_be_login_url реализуйте проверку, что подстрока "login" есть в текущем url браузера. Для этого используйте соответствующее свойство Webdriver.

5. Добавьте изменения в коммит с осмысленным сообщением

Теперь посмотрим, как можно осуществлять переход между страницами. 

----------------------------
# Переходы между страницами

Переход можно реализовать двумя разными способами. 

Первый способ: возвращать нужный Page Object.

Для этого в файле main_page.py нужно сделать импорт страницы с логином: 
```
from .login_page import LoginPage
```
                  
Затем в методе, который осуществляет переход к странице логина, проинициализировать новый объект Page и вернуть его: 
```
def go_to_login_page(self):
    link = self.browser.find_element(*MainPageLocators.LOGIN_LINK)
    link.click()
    return LoginPage(browser=self.browser, url=self.browser.current_url) 
```
                  
Обратите внимание! При создании объекта мы обязательно передаем ему тот же самый объект драйвера для работы с браузером, а в качестве url передаем текущий адрес.

Теперь в тесте нам не нужно думать про инициализацию страницы: она уже создана. Сохранив возвращаемое значение в переменную, мы можем использовать методы новой страницы в тесте:
```
def test_guest_can_go_to_login_page(browser):
    link = "http://selenium1py.pythonanywhere.com"
    page = MainPage(browser, link)
    page.open()
    login_page = page.go_to_login_page()
    login_page.should_be_login_page()
```
                  
Плюсы такого подхода: 

+ тест выглядит аккуратнее — не нужно инициализировать страницу в теле теста;
+ явно возвращаем страницу — тип страницы ассоциирован с методом;
+ не нужно каждый раз думать в разных тестах про инициализацию страницы — уменьшаем дублирование кода;

минусы: 

- если у нас копится большое количество страниц и переходов — образуется много перекрестных импортов;
- большая связность кода — при изменении логики придется менять возвращаемое значение;
- сложнее понимать код, так как страница инициализируется неявно;
- образуются циклические зависимости, что часто приводит к ошибкам.

Второй подход: переход происходит неявно, страницу инициализируем в теле теста: 

1. Закомментируйте строку с возвращаемым значением 
```
def go_to_login_page(self):
    link = self.browser.find_element(*MainPageLocators.LOGIN_LINK)
    link.click()
    # return LoginPage(browser=self.browser, url=self.browser.current_url) 
```
                  
2. Инициализируем LoginPage в теле теста (не забудьте импортировать в файл нужный класс): 
```
from .pages.login_page import LoginPage

def test_guest_can_go_to_login_page(browser):
    link = "http://selenium1py.pythonanywhere.com"
    page = MainPage(browser, link)
    page.open()
    page.go_to_login_page()
    login_page = LoginPage(browser, browser.current_url)
    login_page.should_be_login_page()
```
                  
Плюсы:

+ меньше связность кода;
+ меньше импортов, нет перекрестных импортов;
+ больше гибкость;
+ в тесте понятнее что происходит, т.к. явно инициализируем страницу.

Минусы:

- появляется лишний шаг в тест-кейсе;
- каждый раз при написании теста нужно думать про корректные переходы;
- дублируется код.

И тот и другой подход можно успешно применять в своих проектах, главное делать это с умом. Сейчас оставьте второй вариант с явной инициализацией страниц в теле теста, чтобы избежать лишних сложностей с циклическими зависимостями. 

Уберите лишний закомментированный код, и зафиксируйте изменения в коммите с осмысленным сообщением.

--------------------------------
# Удобство поддержки тестов — инкапсуляция бизнес-логики в методах

Что делать, если изменилась логика взаимодействия со страницей, которая используется у нас в нескольких тестах? Например, нам нужно проверить возможность перехода на страницу логина по ссылке в навбаре для каждой из страниц сайта. Предположим, что таких страниц 20, и, значит, у нас есть 20 тестов, использующих метод go_to_login_page класса MainPage. Затем разработчики добавили alert, который вызывается при клике на нужную нам ссылку. Мы увидим, что все 20 тестов упали, так как в методе go_to_login_page нет шага с обработкой alert, следовательно, метод should_be_login_page не сработает. Добавив обработку alert в метод go_to_login_page, мы восстановим работоспособность всех тестов, не меняя самих тестов:
```
def go_to_login_page(self):
   link = self.browser.find_element(By.CSS_SELECTOR, "#login_link")
   link.click()
   alert = self.browser.switch_to.alert
   alert.accept()
```
                  
Это еще одно преимущество использования паттерна Page Object — мы разделяем сам тест и логику взаимодействия со страницей. Тест становится более читабельным, и его легче поддерживать при изменениях в коде приложения.

------------------------------------------------
# Задание: добавление в корзину со страницы товара

1. Открываем страницу товара (http://selenium1py.pythonanywhere.com/catalogue/the-shellcoders-handbook_209/?promo=newYear). Обратите внимание, что в ссылке есть параметр "?promo=newYear". Не теряйте его в авто-тесте, чтобы получить проверочный код.
2. Нажимаем на кнопку "Добавить в корзину".
3. *Посчитать результат математического выражения и ввести ответ. Используйте для этого метод solve_quiz_and_get_code(), 
который приведен ниже. Например, можете добавить его в класс BasePage, чтобы использовать его на любой странице. 
Этот метод нужен только для проверки того, что вы написали тест на Selenium. 
После этого вы получите код, который нужно ввести в качестве ответа на данное задание. 
Код будет выведен в консоли интерпретатора, в котором вы запускаете тест. 
Не забудьте в конце теста добавить проверки на ожидаемый результат.

Ожидаемый результат: 

1. Сообщение о том, что товар добавлен в корзину. Название товара в сообщении должно совпадать с тем товаром, который вы действительно добавили.
2. Сообщение со стоимостью корзины. Стоимость корзины совпадает с ценой товара. 

Тест нужно написать, используя паттерн Page Object. Для этого вам нужно: 

1. Добавить новый файл для тест-кейсов, связанных со страницей товара. Назовите файл с тестами test_product_page.py.
2. Создать класс Page Object для страницы товара. Опишите его в файле product_page.py в папке pages.
3. Описать в нем метод для добавления в корзину.
4. Дописать методы-проверки.
5. Описать необходимые локаторы к элементам страницы.
6. Написать сам тест-кейс, используя все вышеописанное. Назовите тест test_guest_can_add_product_to_basket.
7. Можете начинать работу с любого пункта, но хорошей практикой считается написать сначала шаги и структуру теста, а потом описывать конкретную реализацию. 

*Используйте этот метод в тесте для получения проверочного кода: 
```
from selenium.common.exceptions import NoAlertPresentException # в начале файла

def solve_quiz_and_get_code(self):
    alert = self.browser.switch_to.alert
    x = alert.text.split(" ")[2]
    answer = str(math.log(abs((12 * math.sin(float(x))))))
    alert.send_keys(answer)
    alert.accept()
    try:
        alert = self.browser.switch_to.alert
        alert_text = alert.text
        print(f"Your code: {alert_text}")
        alert.accept()
    except NoAlertPresentException:
        print("No second alert presented")
```
                  
Чтобы увидеть проверочный код в консоли, запускайте PyTest с параметром -s:
```
pytest -s test_foo.py
```
-------------------------------
# Задание: независимость от данных

Хорошие автотесты должны быть максимально независимы от данных. Худшее, что можно сделать в тесте это "захардкодить" 
проверки для объектов, которые существуют только на вашем конкретном инстансе. Почему? Потому что данные будут постоянно меняться,
и при каждом таком изменении придется чинить автотесты. Еще это ухудшает переиспользование метода: допустим, мы хотим прогнать
тест для множества товаров, тогда придется писать большое количество проверок: по одной для каждого товара. 
В конечном итоге, это сказывается на качестве продукта, так как такие тесты работают на узкой выборке страниц.

Общая рекомендация: ваши тесты не должны зависеть от того, что вы не можете контролировать. 
Это может быть информация, уже хранящаяся в базе данных, или сторонние сервисы, которые использует ваше приложение. 
Вы можете проверять конкретные данные только в случае, когда используете специально подготовленную тестовую базу, 
инициируемую перед каждым запуском тестов, или добавляете нужные данные в базу данных напрямую или через API приложения. 

Попробуйте запустить автотест, который мы написали на предыдущем шаге, на странице http://selenium1py.pythonanywhere.com/catalogue/coders-at-work_207/?promo=newYear2019.

Если в предыдущем тесте после добавления товара в корзину вы проверяли в сообщении сайта фиксированную строку 
"The shellcoder's handbook", то тест упадет, так как теперь мы добавили другой товар. Если тест прошел, 
то вы молодец и можете просто вставить новый проверочный код в этом задании. 

Чтобы тест был независимым от контента: 

Измените методы проверки таким образом, чтобы они принимали как аргумент название товара и цену товара.
Сделайте метод, который вытаскивает из элемента текст-название товара и возвращает его.
Сделайте такой же метод для цены.
Теперь проверяйте, что название товара в сообщении совпадает с заголовком товара.

--------------------------------
# Задание: независимость контента, ищем баг

Эта задача для настоящих ниндзя автотестинга. Не потому что она сложная, а потому что сейчас мы будем ловить с вами настоящий баг
с помощью наших автотестов. Для нашего интернет-магазина было запущено несколько новых промо-акций, 
одна из которых привела к появлению бага. Промо-акция включается путем добавления параметра ?promo=offerN к ссылке на товар.

К счастью, нам не придется менять наш тест, чтобы проверить изменения в коде. 
Мы просто запустим всё тот же тест на странице http://selenium1py.pythonanywhere.com/catalogue/coders-at-work_207/ 
с параметризацией. Вам нужно определить, при каком значении параметра promo автотест упадет. 
Для этого проверьте результат работы PyTest и найдите url, на котором произошла ошибка. 
Значение параметра может изменяться от offer0 до offer9.

Пример ссылки: http://selenium1py.pythonanywhere.com/catalogue/coders-at-work_207/?promo=offer0. 
Если баг будет найден на этой странице, то введите в качестве ответа http://selenium1py.pythonanywhere.com/catalogue/coders-at-work_207/?promo=offer0.

Запустить сразу несколько тестов вы можете, используя @pytest.mark.parametrize. Мы уже сделали для вас шаблон теста:
```
@pytest.mark.parametrize('link', ["http://selenium1py.pythonanywhere.com/catalogue/coders-at-work_207/?promo=offer0",
                                  "http://selenium1py.pythonanywhere.com/catalogue/coders-at-work_207/?promo=offer1",
                                  "http://selenium1py.pythonanywhere.com/catalogue/coders-at-work_207/?promo=offer2",
                                  "http://selenium1py.pythonanywhere.com/catalogue/coders-at-work_207/?promo=offer3",
                                  "http://selenium1py.pythonanywhere.com/catalogue/coders-at-work_207/?promo=offer4",
                                  "http://selenium1py.pythonanywhere.com/catalogue/coders-at-work_207/?promo=offer5",
                                  "http://selenium1py.pythonanywhere.com/catalogue/coders-at-work_207/?promo=offer6",
                                  "http://selenium1py.pythonanywhere.com/catalogue/coders-at-work_207/?promo=offer7",
                                  "http://selenium1py.pythonanywhere.com/catalogue/coders-at-work_207/?promo=offer8",
                                  "http://selenium1py.pythonanywhere.com/catalogue/coders-at-work_207/?promo=offer9"])
def test_guest_can_add_product_to_basket(browser, link):
    # ваша реализация теста
```
                  
Подсказка: баг должен быть найден методом проверки.

После того как вы обнаружили баг, учитывая что чинить его не собираются, лучше всего пометить падающий тест как xfail или skip. 
Помните, как мы такое проворачивали в третьем модуле? Освежить память: XFail: помечать тест как ожидаемо падающий.

С параметризацией делается это примерно так:  
```
@pytest.mark.parametrize('link', ["okay_link",
                                  pytest.param("bugged_link", marks=pytest.mark.xfail),
                                  "okay_link"])
```

После всех манипуляций не забудьте зафиксировать изменения коммитом.

-------------------------------------
# Отрицательные проверки: как проверить отсутствие элемента

1. Элемент потенциально может появиться на странице (но вообще-то не должен). 
Например, мы открываем страницу товара, и ожидаем, что там нет сообщения об успешном добавлении в корзину. 
Мы проверяем, что элемента нет, но при позитивном сценарии, когда мы добавляем товар в корзину, сообщение тоже появляется
не сразу. Если при негативной проверке мы не добавим ожидание, а сразу выдадим результат: "True, элемента действительно нет, 
все хорошо", мы рискуем нарваться на ложно-зеленый тест. То есть, можем пропустить баг. 

2. Элемент присутствует на странице и должен исчезнуть со временем или в результате действий пользователя. 
Это может быть, например, удаление товара из корзины, или исчезновение лоадера с загрузкой. 

Почему нужно писать такие проверки с осторожностью? 
Во-первых, нам приходится всегда гарантированно ждать. 
В первом примере нам всегда нужно ждать несколько секунд, чтобы убедиться, что элемент не появился. 
Если мы используем нашу написанную функцию is_element_present, то тест с такой проверкой будет ждать полные и честные 10 секунд:
```
def should_not_be_success_message(self):
    assert not self.is_element_present(*ProductPageLocators.SUCCESS_MESSAGE),\
        "Success message is presented"
```
                  
Что очень много для зелёного теста. То есть implicit_wait уже в такой ситуации не подходит, 
придется использовать явное ожидание и аккуратно подбирать условия. 
Время ожидания тоже придется подбирать эмпирически, путем проб, ошибок, ложноположительных и ложноотрицательных результатов. 

Во-вторых, еще одна загвоздка с отрицательными проверками в том, что они могут давать ложноположительные срабатывания, 
если селектор устарел. Проверяем, что элемента с таким селектором нет, — проверка проходит, 
так как у элемента уже другой селектор. Элемент есть на экране — это баг, а тест зеленый. Это плохо! 

Поэтому на каждый негативный тест обязательно должен приходиться положительный тест. 
В одном тесте проверяем, что элемента нет, в соседнем тесте, что элемент есть. 
Тогда мы сможем отслеживать актуальность селектора и не пропустим такой баг.

Как же тогда реализовывать такие проверки? 

Нужно ориентироваться на конкретную ситуацию, но общий совет — использовать явные ожидания и Expected Conditions, о которых мы говорили в предыдущих модулях. 

Можно добавить в BasePage абстрактный метод, который проверяет, что элемент не появляется на странице в течение заданного времени: 
```
def is_not_element_present(self, how, what, timeout=4):
    try:
        WebDriverWait(self.browser, timeout).until(EC.presence_of_element_located((how, what)))
    except TimeoutException:
        return True

    return False
```
                  
Тогда его использование Page Object для страницы товара будет выглядеть так: 
```
def should_not_be_success_message(self):
    assert self.is_not_element_present(*ProductPageLocators.SUCCESS_MESSAGE), \
       "Success message is presented, but should not be"
```
                  
Если же мы хотим проверить, что какой-то элемент исчезает, то следует воспользоваться явным ожиданием 
вместе с функцией until_not, в зависимости от того, какой результат мы ожидаем: 
```
def is_disappeared(self, how, what, timeout=4):
    try:
        WebDriverWait(self.browser, timeout, 1, TimeoutException).\
            until_not(EC.presence_of_element_located((how, what)))
    except TimeoutException:
        return False

    return True
```
                  
Метод-проверка в классе про страницу товара будет выглядеть аналогично should_not_be_success_message, напишите его самостоятельно.

Обратите внимание на разницу между методами is_not_element_present и is_disappeared. 

is_not_element_present: упадет, как только увидит искомый элемент. Не появился: успех, тест зеленый. 

is_disappeared: будет ждать до тех пор, пока элемент не исчезнет. 

Резюмируя, можно сказать, что разрабатывать такие проверки нужно очень аккуратно, использовать явные ожидания для сокращения
времени прогона теста и всегда добавлять позитивную проверку на элемент в другом тесте. 
Без явной необходимости таких проверок лучше избегать. 

---------------------------------------
# Задание: отрицательные проверки

Добавьте к себе в проект функции из предыдущего шага и реализуйте несколько простых тестов: 

test_guest_cant_see_success_message_after_adding_product_to_basket: 
1. Открываем страницу товара 
2. Добавляем товар в корзину 
3. Проверяем, что нет сообщения об успехе с помощью is_not_element_present

test_guest_cant_see_success_message: 
1. Открываем страницу товара 
2. Проверяем, что нет сообщения об успехе с помощью is_not_element_present

test_message_disappeared_after_adding_product_to_basket: 
1. Открываем страницу товара
2. Добавляем товар в корзину
3. Проверяем, что нет сообщения об успехе с помощью is_disappeared

Запустите все три теста, и отметьте ниже верные утверждения для каждого теста.

Важно! После того как пройдете это задание, те тесты, которые упали пометьте как XFail или skip. 

------------------------------------


